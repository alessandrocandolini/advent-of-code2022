{-# LANGUAGE DerivingVia #-}
module Day2(play, winner, Move(..), Score(..), Match(..), Winner(..)) where

program :: String -> IO ()
program _ = pure ()

data Move = Rock | Paper | Scissors deriving (Eq,Show, Bounded, Enum)

newtype Score = Score Int deriving (Eq, Show, Num, Ord) via Int

data Match = Match Move Move deriving (Eq,Show)

data Winner = Player1 | Player2 | Draw deriving (Eq,Show)

data Scores = Scores {
   score1 :: Score,
   score2 :: Score
   } deriving (Eq,Show)

cyclicSucc :: (Eq a, Enum a, Bounded a) => a -> a
cyclicSucc a | a == maxBound = minBound
          | otherwise = succ a

scoreMove :: Move -> Score
scoreMove = (+ 1) . fromIntegral . fromEnum
--score Rock = 1
--score Paper = 2
--score Scissors = 3

--winnerScore :: Winner -> Score
--scoreOutcome = (* 3) . fromEnum
--scoreOutcome Loss = 0
--scoreOutcome Draw = 3
--scoreOutcome Win = 6

parse1 :: Char -> Maybe Move
parse1 'A' = Just Rock
parse1 'B' = Just Paper
parse1 'C' = Just Scissors
parse1 _ = Nothing

parse2 :: Char -> Maybe Move
parse2 'X' = Just Rock
parse2 'Y' = Just Paper
parse2 'Z' = Just Scissors
parse2 _ = Nothing

play :: Match -> Winner
play (Match m1 m2) | m2 == m1 = Draw
                     | m2 == cyclicSucc m1 = Player2
                     | otherwise = Player1


score :: Player -> Match
